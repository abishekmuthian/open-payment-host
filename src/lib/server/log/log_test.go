package log

import (
	"bytes"
	"fmt"
	"io"
	"io/ioutil"
	"net/http"
	"net/http/httptest"
	"os"
	"strings"
	"testing"
)

// logTest is used to test the output generated by key/value pairs.
type logTest struct {
	values   V
	expected string
}

func (l *logTest) String() string {
	return fmt.Sprintf("TEST-%s", l.expected)
}

var logTests = []logTest{
	{
		expected: "service:debugging",
		values: V{
			"service": "debugging",
			"key":     1,
		},
	},
	{
		expected: "key:1",
		values: V{
			"service": "debugging",
			"key":     1,
		},
	},
	{
		expected: "key:-43",
		values: V{
			"service": V{"test": 3.0},
			"key":     -43,
		},
	},
	{
		expected: "service:map[test:3]",
		values: V{
			"service": V{"test": 3},
			"key":     -43,
		},
	},
	{
		expected: "struct:TEST-foobar ",
		values: V{
			"service": "`'log_test'a`accentÃ©`df!#$!@#%^",
			"struct":  &logTest{expected: "foobar"},
		},
	},
}

// Test logging to the default logger
func TestDefault(t *testing.T) {
	logger, err := NewStdErr("myapp: ")
	if err != nil {
		t.Fatalf("log: error creating default logger :%s", err)
	}

	// Record what is written for testing
	var recorder bytes.Buffer
	logger.Writer = &recorder

	// Test levels
	logger.Level = LevelError

	// Add to our list of outputs
	Add(logger)

	// Add another logger just to check
	auxillaryLogger, err := NewStdErr("auxillary: ")
	if err != nil {
		t.Fatalf("log: error creating aux logger :%s", err)
	}
	var recorder2 bytes.Buffer
	auxillaryLogger.Writer = &recorder2
	auxillaryLogger.Level = LevelDebug
	Add(auxillaryLogger)

	// Write out a string at debug level
	Debug(logTests[0].values)
	Debug(logTests[1].values)

	result, err := recorder.ReadString('\n')
	if err != nil && err != io.EOF {
		t.Fatalf("log: error on default logger %s", err)
	}
	if len(result) > 0 {
		t.Fatalf("log: debug logging wrote to logger got:%s", result)
	}

	// Test the auxillary logger for output
	result, err = recorder2.ReadString('\n')
	if err != nil {
		t.Fatalf("log: error on aux logger %s", err)
	}
	if len(result) == 0 {
		t.Fatalf("log: aux log empty got:%s", result)
	}

	// Check that logging has the expected results
	for _, test := range logTests {

		// Write to log
		Error(test.values)

		// Test reading recorder line
		result, err := recorder.ReadString('\n')
		if err != nil && err != io.EOF {
			t.Fatalf("log: error on default logger %s", err)
		}
		// Check expected strings
		if !strings.Contains(result, test.expected) {
			t.Fatalf("log: mismatch on default logger expected:%s got:%s", test.expected, result)
		}
	}

}

// TestFile tests the file logger (might fail in some environments)
// this test requires write access to the pkg directory
func TestFile(t *testing.T) {
	// Create file logger at a given path (we must have permissions to do so)
	path := "test.log"
	logger, err := NewFile(path)
	if err != nil {
		t.Fatalf("log: error creating file logger :%s", err)
	}

	logger.Prefix = "HYPERLOG: "

	// Add to our list of outputs
	Add(logger)

	// Write to logger
	Fatal(V{"action": "fatal"})

	// Test the file exists
	_, err = os.Stat(path)
	if err != nil {
		t.Fatalf("error creating log file %s", err)
	}

	// Read file to check contents
	got, err := ioutil.ReadFile(path)
	if err != nil {
		t.Fatalf("error reading log file %s", err)
	}

	// Delete the file after test, regardless of outcome
	err = os.Remove(path)
	if err != nil {
		t.Fatalf("error deleting test.log file %s", err)
	}

	expected := "HYPERLOG: action:fatal #fatal"
	if !strings.HasPrefix(string(got), expected) {
		t.Fatalf("error reading log file expected:\n%s got:\n%s\n", expected, string(got))
	}

}

// TestInvalidLevels tests we don't panic if invalid level key is set
func TestInvalidLevels(t *testing.T) {
	logger, err := NewStdErr("myapp: ")
	if err != nil {
		t.Fatalf("log: error creating default logger :%s", err)
	}
	// Write to a buffer to avoid spamming stdout
	var recorder2 bytes.Buffer
	logger.Writer = &recorder2
	Add(logger)
	Debug(V{LevelKey: 2})
	Info(V{LevelKey: nil})
	Error(V{ErrorKey: nil})
	Fatal(V{LevelKey: t})
	Log(V{LevelKey: 2e21})
	Log(V{LevelKey: nil})
	Log(V{LevelKey: t})
	logger.LevelValue(V{LevelKey: -5e21})
	logger.LevelValue(V{LevelKey: t})
	logger.LevelValue(V{LevelKey: nil})
}

// TestTrace tests tracing using the context pkg is working correctly.
func TestTrace(t *testing.T) {
	logger, err := NewStdErr("myapp: ")
	if err != nil {
		t.Fatalf("log: error creating default logger :%s", err)
	}
	// Write to a buffer to avoid spamming stdout
	var recorder2 bytes.Buffer
	logger.Writer = &recorder2
	Add(logger)

	// Setup request and recorder
	r := httptest.NewRequest("GET", "/users/create", nil)
	w := httptest.NewRecorder()

	// Add to context for request
	fn := Middleware(mockHandler)

	// Call middleware
	fn(w, r)

	// Get value back out of context
	Trace(r)
}

func mockHandler(w http.ResponseWriter, r *http.Request) {
	w.Write([]byte("hello world"))
}
